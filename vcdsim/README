
.global reset
reset:
    mov.w #0x5A80,&0x120
    bis.b #0x41,&0x22

    bis.b #0x01,&0x21
    bic.b #0x40,&0x21

loop:
    xor.b #0x41,&0x21
    mov #0,r5
    mov #2,r6
loop0:
    sub #1,r5
    jnz loop0
    ;sub #1,r6
    ;jnz loop0

    jmp loop

.global hang
hang:
    jmp hang

.word hang      /* 0xFFE0 */
.word hang      /* 0xFFE2 */
.word hang      /* 0xFFE4 */
.word hang      /* 0xFFE6 */
.word hang      /* 0xFFE8 */
.word hang      /* 0xFFEA */
.word hang      /* 0xFFEC */
.word hang      /* 0xFFEE */
.word hang      /* 0xFFF0 */
.word hang      /* 0xFFF2 */
.word hang      /* 0xFFF4 */
.word hang      /* 0xFFF6 */
.word hang      /* 0xFFF8 */
.word hang      /* 0xFFFA */
.word hang      /* 0xFFFC */
.word reset     /* 0xFFFE */


which produces this

0000ffe0 <VECTORS>:
    ffe0:   26 fc           interrupt service routine at 0xfc26
    ffe2:   26 fc           interrupt service routine at 0xfc26
    ffe4:   26 fc           interrupt service routine at 0xfc26
    ffe6:   26 fc           interrupt service routine at 0xfc26
    ffe8:   26 fc           interrupt service routine at 0xfc26
    ffea:   26 fc           interrupt service routine at 0xfc26
    ffec:   26 fc           interrupt service routine at 0xfc26
    ffee:   26 fc           interrupt service routine at 0xfc26
    fff0:   26 fc           interrupt service routine at 0xfc26
    fff2:   26 fc           interrupt service routine at 0xfc26
    fff4:   26 fc           interrupt service routine at 0xfc26
    fff6:   26 fc           interrupt service routine at 0xfc26
    fff8:   26 fc           interrupt service routine at 0xfc26
    fffa:   26 fc           interrupt service routine at 0xfc26
    fffc:   26 fc           interrupt service routine at 0xfc26
    fffe:   00 fc           interrupt service routine at 0xfc00

Disassembly of section .text:

0000fc00 <reset>:
    fc00:   b2 40 80 5a     mov #23168, &0x0120 ;#0x5a80
    fc04:   20 01
    fc06:   f2 d0 41 00     bis.b   #65,    &0x0022 ;#0x0041
    fc0a:   22 00
    fc0c:   d2 d3 21 00     bis.b   #1, &0x0021 ;r3 As==01
    fc10:   f2 c0 40 00     bic.b   #64,    &0x0021 ;#0x0040
    fc14:   21 00

0000fc16 <loop>:
    fc16:   f2 e0 41 00     xor.b   #65,    &0x0021 ;#0x0041
    fc1a:   21 00
    fc1c:   05 43           clr r5      ;
    fc1e:   26 43           mov #2, r6  ;r3 As==10

0000fc20 <loop0>:
    fc20:   15 83           dec r5      ;
    fc22:   fe 23           jnz $-2         ;abs 0xfc20
    fc24:   f8 3f           jmp $-14        ;abs 0xfc16

0000fc26 <hang>:
    fc26:   ff 3f           jmp $+0         ;abs 0xfc26

And that is the program we want to simulate first.

coming out of reset we need to read the reset vector


post_reset
reset state fetch 0xFFFE get 0xFC00


fc00: 0x40B2 0x5A80 0x0120 mov #0x5A80,&0x0120

fetch opcode inst fetch 0xFC00 get 0x40B2
0x40B2  0100000010110010

0100 0000 1 0 11 0010 -> mov src 0000 ad 1 bw 0 as 11 dest 0010

as of 11 with src of 0000 means immediate, source is next word in
instruction stream so we have to fetch

fetch 0xFC02 get 0x5A80 source_data is 0x5A80

ad is 1 dest is 0010 so address is a fetch

fetch 0xFC04 get 0x0120 dest_add is 0x0120

this is a move so we dont need to read 0x0120

bw is 0 so this is a word mov

store 0x5A80 to [0x0120]






















$version Generated by VerilatedVcd $end
$date Wed Oct 19 15:01:01 2011
 $end
$timescale 1ns $end

 $scope module TOP $end
  $var wire  1 < clock_in $end
  $var wire 16 B mem_add [15:0] $end
  $var wire  1 ? mem_fetch $end
  $var wire 16 = mem_in [15:0] $end


  $scope module v $end
   $var wire  1 < clock_in $end
   $var wire 16 ; inst [15:0] $end
  $upscope $end
 $upscope $end
$enddefinitions $end



#1
b0000 #
b00000000000000000 $
b00000000000000000 %
b00000000000000000 &

single bit ones dont need the b or a space:

1.
0/
b0000000000000000 0
b0000000000000000 1
02
03

#2
1<
#3
0<

the file just ends, nothing special to close it out.


















